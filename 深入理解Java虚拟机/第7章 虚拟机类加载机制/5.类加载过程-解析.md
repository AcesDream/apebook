### 7.3.4 解析

　　解析阶段是虚拟机将向常量池内符合引用替换为直接引用的过程。

+ 符合引用：是一组符合来描述所引用的目标，符合可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符合引用于虚拟机实现的内存布局无关，因为符合引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
+ 直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符合引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用目标必定已经在内存中存在。

　　对同一个符合引用进行多次解析请求是很常见的事情，除了invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一致成功，同样的，如果第一次解析失败了，那么其他指令对这个符号的解析请求也应该收到相同的异常。

　　对于invokedynamic指令，上面的规则不成了。因为invokedynamic指令的目的本来就是用于动态语言支持，它所对应的引用称为“动态调用点限定符”，这里的“动态”的含义就是碧玺等到程序实际运行到这条指令的时候，解析动作才能进行，相对的，其余可触发解析的指令都是“静态的”，可以再刚刚完成加载阶段，还没有开始执行代码的时候就进行解析。

　　解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符合引用进行，分别对应常量池的CONSTANT\_Class\_info、CONSTANT\_Fieldref\_info、CONSTANT\_Methodref\_info、CONSTANT\_InterfaceMethodref\_info、CONSTANT\_MethodType\_info、CONSTANT\_MethodHandle\_info和CONSTANT\_InvokeDynamic\_info7中常量类型。

#### 1.类或接口的解析

　　假设当前代码所处的类为D，如果要把一个从未解析过的符合引用N解析为一个类或接口C的直接引用，那虚拟机完整整个解析的过程需要以下3个步骤：

1. 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证，字节码验证的需要，又可能触发其他相关类的加载动作，一旦这个加载过程中出现了任何一次，解析过程就宣告失败。
2. 如果C是一个数组类型，并且数组的元数据类型为对象，也就是N的描述符会是类似“\[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元数据类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
3. 如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了但在解析完成之前还要进行符合引用的验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IlleagalAccessError。


#### 2.字段解析

　　在进行字段解析之前，会先对字段表内class\_index项中索引的CONSTANT\_Class\_info符合引用进行解析，，如果解析成功，那么这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：

1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，返回这个字段的直接引用，查找结束。
2. 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符斗鱼目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4. 否则查找结束，抛出java.lang.NoSuchFieldError。

　　如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IlleagalAccessError异常。

　　在实际应用中，虚拟机编译器的实现可能会比上述规范要求的更加严格一些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中，那编译器将可能拒绝编译。

	public class FieldResolution {
	    interface Interface0 {
	        int A = 0;
	    }
	    
	    interface Interface1 extends Interface0 {
	        int A = 1;
	    }
	    
	    interface Interface2 {
	        int A = 2;
	    }
	    
	    static class Parent implements Interface1 {
	        public static int A = 3;
	    }
	    
	    static class Sub extends Parent implements Interface2 {
	        /*
	         * 如果注释掉这个定义，编译器将会报错：The field Sub.A is ambiguous
	         * */
	        public static int A = 4;
	    }
	    
	    public static void main(String[] args) {
	        System.out.println(Sub.A);
	    }
	}

#### 3.类方法解析

　　在进行类方法解析之前，也需要先解析出类方法表的class\_index项中索引的方法所属的类或接口的符合引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：

1. 类方法和接口方法符合引用的常量类型定义是分开的，如果在类方法表中发现class\_index中索引的C是个接口，那就直接抛出异常java.lang.IncompatibleClassChangeError。
2. 如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。
5. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。
　　如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IlleagalAccessError异常。

#### 4.接口方法解析

　　在进行接口方法解析之前，也需要先解析出接口方法表的class\_index项中索引的方法所属的类或接口的符合引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：

1. 与类方法解析不同，如果在接口方法表中发现class\_index中索引的C是个类而不是接口，那就直接抛出异常java.lang.IncompatibleClassChangeError。
2. 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在接口C的父接口中递归查找，直到java.lang.Object，查找范围包括Object类，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。

　　由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符合解析应当不会抛出java.lang.IlleagalAccessError异常。
