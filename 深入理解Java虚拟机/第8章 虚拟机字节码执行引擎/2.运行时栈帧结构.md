## 8.2 运行时栈帧结构

　　栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。

　　每一个栈帧都包括了局部变量表、操作数栈、动态链接和方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

　　一个线程中的方法调用链可能会很长，很多方法都同时处理执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有的字节码指令都只针对当前栈帧进行操作。在概念模型上，典型的栈帧结构如图8-1所示。

## 8.2.1 局部变量表

　　局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，在Java程序编译为Class文件时，就在方法的Code属性的max\_locals数据项中确定了该方法所需分配的局部变量表的最大容量。局部变量表的容量以Slot为最小单位。

　　一个Slot可以存放一个32位以内的数据类型，Java中32位以内的数据类型有boolean、byte、char、short、int、float、reference和returnAddress8种类型。其中reference类型表示对一个对象实例的引用，虚拟机规范没有定义它的长度和结构，一般来讲，虚拟机实现至少都应当能通过这个引用做到这两点，一是从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息。returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr\_w和ret服务的，指向了一条字节码指令的地址，很古老的Java虚拟机曾经使用这几条指令来实现异常处理，现在已经由异常表代替。

　　对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，索引n就代表了第n个Slot，如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot，对于两个相邻的共同存放一个64位数据的Slot，不允许采用任何方法单独访问其中某一个，Java虚拟机规范中明确要求了如果遇到这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。

　　在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法，那局部变量表中第0位索引的Slot默认是用于传递方法所属对应实例的引用，在方法中可以通过this来访问到这个隐含参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其他的Slot。

　　局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。不过这也会有一些副作用，详见下面代码演示示例。

	//java -verbose:gc Test，不会内存回收
	public class Test {
		public static void main(String[] args) {
	
			byte[] placeholder = new byte[64 * 1024 * 1024];
			System.gc();
		}
	}
	//java -verbose:gc Test，不会内存回收
	public class Test {
		public static void main(String[] args) {
			{
				byte[] placeholder = new byte[64 * 1024 * 1024];
			}
			int a = 0;
			System.gc();
		}
	}
	//java -verbose:gc Test，会内存回收
	public class Test {
		public static void main(String[] args) {
			{
				byte[] placeholder = new byte[64 * 1024 * 1024];
			}
			int a = 0;
			System.gc();
		}
	}

　　为什么会出现上面的现象？placeholder能否被回收的根本原因是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一段，因为placeholder还在作用域，所以不会回收；第二段，虽然placeholder不在作用域，但是没有任何对局部变量表的读写操作，placeholder原本占用的Slot还没有被其他变量所服用，所欲GC Roots一部分的局部变量表仍然保持着对它的关联，这种关联没有被及时打断，在绝大多数情况下影响都很轻微。

　　我们知道类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。对于局部变量就不一样了，他们没有上面的过程，如果一个局部变量定义了但没有赋初始值是不能使用的。


## 8.2.2 操作数栈

　　操作数栈也称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max\_stacks数据项中。操作数栈的每一个元素可以是任意类型的Java数据类型。32位数据类型占用的栈容量为1,64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max\_stacks数据项中设定的最大值。

　　当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令王操作数栈中写入和提取内容，也就是出栈和入栈操作。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类型校验阶段的数据流分析中还要再次验证这一点。

　　另外，在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多数虚拟机的实现里面都会做一些优化处理，令两个栈帧出现一部分重叠。让下面的栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样再进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。

## 8.2.3 动态连接

　　每个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析，另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。

## 8.2.4 方法返回地址

　　当一个方法开始执行后，只有两种方式可以退出这个方法。
+ 正常完成出口：是执行引擎遇到任意一个方法返回的字节码指令，这时候可能有返回值传递给上层的方法调用者，是否有返回值和返回值的类型都将根据遇到何种方法返回指令来决定。
+ 异常完成出口：是在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。

　　无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。









