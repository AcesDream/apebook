## 8.3 方法调用

　　方法调用并不等同于方法执行，方法调用阶段唯一性的任务就是确定被调用方法的版本号，暂时还不涉及方法内部的具体运行过程。

### 8.3.1 解析

　　所有方法调用中的目标方法在Class文件里面都是一个常量池中的符合引用，在类加载的解析阶段，会将其中的一部分符合引用转化为直接引用。这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析。

　　在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们多不可能通过继承或别的方法重写其他版本，因此他们都适合在类加载阶段进行解析。

　　与之相对应的是，在Java虚拟机里面提供了5条方法调用字节码指令，分别如下：

+ invokestatic：调用静态方法
+ invokespecial：调用实例构造器<init>方法、私有方法和父类方法
+ invokevirtual：调用所有的虚方法
+ invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。
+ invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

　　只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符合引用解析为该方法的直接引用。这些方法称为非虚方法，其他的方法称为虚方法。

　　Java中的非虚方法除了使用invokestatic、invokespecial调用的方法之外还有一种，就是被final修饰的方法。虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在Java语言规范中明确说明了final方法是一种非虚方法。

　　解析调用是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符合引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的，也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分派方式的两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派。
