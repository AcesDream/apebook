### 13.2.2 线程安全的实现方法

　　了解了什么是线程安全之后，紧接着的一个问题就是我们应该如何实现线程安全，这听起来似乎是一件由代码如何编写来决定的事情，确实，如何实现线程安全与代码编写有很大的关系，但虚拟机提供的同步和锁机制也起到了非常重要的作用。

#### 1.互斥同步

　　互斥同步是常见的一种并发正确性保障收到，同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。而互斥是实现同步的一种手段。互斥是因，同步是果；互斥是方法，同步是目的。

　　在Java中，最基本的互斥同步手段就是使用synchronized关键字。synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为所对象。

　　根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器Wie0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放位置。

　　synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题，其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。

　　除了synchronized之外，我们还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步。在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别（lock()和unlock()）。不过相比synchronized，ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁、以及锁可以绑定多个条件。

+ 等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断性对处理执行时间非常长的同步块很有帮助。
+ 公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序依次获得锁，而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁时 非公平的，ReentrantLock默认情况下也是非公平的，但是可以通过带布尔值的构造函数要求使用公平锁。
+ 锁绑定多个条件：指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次条用newCondition()方法即可。

　　在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。


#### 2.非阻塞同步

　　互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和简称是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。

　　为什么说使用乐观并发策略需要“硬件指令集的发展”才能进行呢？因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：

+ 测试并设置（Test and set）
+ 获取并增加（Fetch and Increment）
+ 交换（swap）
+ 比较并交换（Compare and swap，下文简称CAS）
+ 加载链接/条件存储（Load linked/store conditional，下文称LL/SC）

　　其中，前面3条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能是类似的。

　　CAS指令需要有3个操作数，分别是内存位置（V），旧的预期值（A）和新值（B）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。

　　在JDK1.5之后，Java程序中可以使用CAS操作，该操作由sun.misc.Unsafe类里面的几个方法包装提供。Unsafe类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器加载的Class才能访问它），因此如果不采用反射收到，我们只通过其他的API来间接的使用它。

　　尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，存在这样一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说它的值没有被其他线程改变过了吗？如果这段时间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改为传统的互斥同步可能会比原子类更高效。


#### 3.无同步方案

　　要保证线程安全，并不是一定要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的收到，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。因此会有一些代码天生就是线程安全的。

+ 可重入代码：这种diamante也叫做纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并发所有的线程安全的代码都是可重入的。可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就能都返回相同的结果，那它就满足可冲入性的要求，当然也就是线程安全的。
+ 线程本地存储（Thread Local Storage）：如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码能否保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。符合这种特点的应用并不少见，大部分使用消费队列的架构模式都将会将消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典的Web交互模型中的“一个请求对应一个服务器线程”的处理方式。